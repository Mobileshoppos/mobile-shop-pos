-- supabase/migrations/20250928035119_create_purchase_returns_table_and_function.sql

-- Step 1: Create the main table to record each return event
CREATE TABLE public.purchase_returns (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    purchase_id bigint NOT NULL REFERENCES public.purchases(id),
    supplier_id bigint NOT NULL REFERENCES public.suppliers(id),
    return_date date NOT NULL DEFAULT now(),
    total_return_amount numeric NOT NULL CHECK (total_return_amount >= 0),
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Step 2: Create a table to record which specific items were returned in each event
CREATE TABLE public.purchase_return_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    return_id bigint NOT NULL REFERENCES public.purchase_returns(id) ON DELETE CASCADE,
    product_id bigint NOT NULL REFERENCES public.products(id),
    inventory_id_original bigint NOT NULL, -- The original ID from the inventory table
    imei text,
    purchase_price numeric NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Add comments to explain the tables
COMMENT ON TABLE public.purchase_returns IS 'Stores a record for each purchase return transaction.';
COMMENT ON TABLE public.purchase_return_items IS 'Stores the individual items that were part of a purchase return.';
COMMENT ON COLUMN public.purchase_return_items.inventory_id_original IS 'The ID of the item in the inventory table before it was deleted.';


-- Step 3: Create the function to process the entire return logic safely
CREATE OR REPLACE FUNCTION public.process_purchase_return(
    p_purchase_id integer,
    p_item_ids integer[],
    p_return_date date,
    p_notes text
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_supplier_id integer;
    v_total_return_amount numeric := 0;
    v_new_return_id bigint;
    item_record record;
BEGIN
    -- Get the supplier_id from the purchase
    SELECT supplier_id INTO v_supplier_id FROM public.purchases WHERE id = p_purchase_id;

    -- Calculate the total value of the items being returned
    SELECT COALESCE(SUM(purchase_price), 0)
    INTO v_total_return_amount
    FROM public.inventory
    WHERE id = ANY(p_item_ids);

    -- If there's nothing to return, exit gracefully
    IF v_total_return_amount <= 0 THEN
        RETURN;
    END IF;

    -- Create a new record in the main purchase_returns table
    INSERT INTO public.purchase_returns (purchase_id, supplier_id, return_date, total_return_amount, notes)
    VALUES (p_purchase_id, v_supplier_id, p_return_date, v_total_return_amount, p_notes)
    RETURNING id INTO v_new_return_id;

    -- Loop through each item to be returned
    FOR item_record IN
        SELECT * FROM public.inventory WHERE id = ANY(p_item_ids)
    LOOP
        -- Add a record for the specific item in purchase_return_items
        INSERT INTO public.purchase_return_items (return_id, product_id, inventory_id_original, imei, purchase_price)
        VALUES (v_new_return_id, item_record.product_id, item_record.id, item_record.imei, item_record.purchase_price);
    END LOOP;

    -- IMPORTANT: Delete the returned items from the active inventory
    DELETE FROM public.inventory WHERE id = ANY(p_item_ids);

    -- Update the original purchase record: reduce totals and balance
    UPDATE public.purchases
    SET
        total_amount = total_amount - v_total_return_amount,
        balance_due = balance_due - v_total_return_amount,
        -- Recalculate the status
        status = CASE
            WHEN (balance_due - v_total_return_amount) <= 0 THEN 'paid'
            WHEN amount_paid > 0 AND (balance_due - v_total_return_amount) > 0 THEN 'partially_paid'
            ELSE 'unpaid'
        END
    WHERE id = p_purchase_id;

END;
$$;